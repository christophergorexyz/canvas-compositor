{"version":3,"sources":["../src/VectorPath.js"],"names":["VectorPath","options","_vertices","vertices","_zeroedBoundingBox","x","y","inside","l","Line","Vector","compoundScale","offset","i","_zeroedVertices","length","j","v","_scaleVectorXY","scaleWidth","scaleHeight","add","w","edgeDirection","subtract","normalize","edge","intersection","intersectionWith","intersectToTheRight","Number","EPSILON","negativeX","negativeY","leftVertex","rightVertex","topVertex","bottomVertex","intersectWithinSegment","boundingBox","pathToDraw","map","vertex","left","top","_prerenderingContext","style","right","_right","_left","bottom","_bottom","_top","lineWidth","verts","yCoordinates","xCoordinates","Math","min","apply","max","d","PrimitiveComponent","vector","scaleX","scaleY"],"mappings":"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","sourcesContent":["import {\r\n    drawPath\r\n} from './Renderer';\r\nimport {\r\n    PrimitiveComponent\r\n} from './PrimitiveComponent';\r\nimport {\r\n    Vector\r\n} from 'vectorious';\r\nimport {\r\n    Line\r\n} from './Line';\r\n\r\n//would name the file 'path', but damn near everything\r\n//relies on the filesystem 'path' module\r\n\r\n/**\r\n * An ordered set of vectors defining a path\r\n */\r\nexport class VectorPath extends PrimitiveComponent {\r\n    /**\r\n     * see PrimitiveComponent for more options\r\n     * @param {Object} options the options for the object\r\n     * @param {Object[]} options.vertices the vertices\r\n     * @param {number} options.vertices[].x the y coordinate for a vertex\r\n     * @param {number} options.vertices[].y the y coordinate for a vertex\r\n     */\r\n    constructor(options) {\r\n        super(options);\r\n\r\n        /**\r\n         * The sequence of vertices in the path\r\n         */\r\n        this._vertices = [];\r\n        this.vertices = options.vertices || [];\r\n\r\n        //this.unscaledLineWidth = this.style.lineWidth;\r\n\r\n        /**\r\n         * A zeroed bounding box where (left, top) is (0, 0)\r\n         */\r\n        this._zeroedBoundingBox = null;\r\n    }\r\n\r\n    /**\r\n     * get the bounding box for the vertices in the path\r\n     * @type {{top:number, left: number, bottom:number, right:number}} boundingBox\r\n     * @property {number} top the coordinate of the top edge of the bounding box\r\n     * @property {number} left the coordinate of the left edge of the bounding box\r\n     * @property {number} right the coordinate of the right edge of the bounding box\r\n     * @property {number} bottom the coordinate of the bottom edge of the bounding box\r\n     */\r\n    get boundingBox() {\r\n        /**\r\n         * The bounding box zeroed\r\n         * @property {number} top always 0\r\n         * @property {number} left always 0\r\n         * @property {number} right the distance from the leftmost vector to the rightmost\r\n         * @property {number} bottom the distance from the topmost vector to the bottommost\r\n         */\r\n        this._zeroedBoundingBox = {\r\n            top: 0,\r\n            left: 0,\r\n            right: this._right - this._left,\r\n            bottom: this._bottom - this._top\r\n        };\r\n\r\n        //TODO: reimplement scaling\r\n        return {\r\n            top: this._zeroedBoundingBox.top + this.offset.y - this.style.lineWidth,\r\n            left: this._zeroedBoundingBox.left + this.offset.x - this.style.lineWidth,\r\n            bottom: this._zeroedBoundingBox.bottom + this.offset.y + this.style.lineWidth,\r\n            right: this._zeroedBoundingBox.right + this.offset.x + this.style.lineWidth\r\n        };\r\n    }\r\n\r\n    /**\r\n     * retrieve the list of vertices\r\n     * @type {Array<{x: number, y: number }>} the sequence of vertices in the path\r\n     */\r\n    get vertices() {\r\n        return this._vertices;\r\n    }\r\n\r\n    /**\r\n     * set the list of vertices\r\n     * @param {Array<{x: number, y: number }>} verts The list of vertices to be used\r\n     */\r\n    set vertices(verts) {\r\n        /**\r\n         * the list of vertices as vectorious Vectors\r\n         * @type {object[]} vertices\r\n         */\r\n        this._vertices = verts.map(v => new Vector([v.x, v.y]));\r\n\r\n        let yCoordinates = this.vertices.map(v => v.y);\r\n        let xCoordinates = this.vertices.map(v => v.x);\r\n\r\n        //uses `apply` so we can supply the list as a list of arguments\r\n        /**\r\n         * @type {number} the leftmost x-coordinate\r\n         */\r\n        this._left = Math.min.apply(null, xCoordinates);\r\n\r\n        /**\r\n         * @type {number} the topmost y-coordinate\r\n         */\r\n        this._top = Math.min.apply(null, yCoordinates);\r\n\r\n        /**\r\n         * @type {number} the rightmost x-coordinate\r\n         */\r\n        this._right = Math.max.apply(null, xCoordinates);\r\n\r\n        /**\r\n         * @type {number} the bottommost y-coordinate\r\n         */\r\n        this._bottom = Math.max.apply(null, yCoordinates);\r\n\r\n        super.d = new Vector([this._left, this._top]);\r\n\r\n        /**\r\n         * Vertices zeroed against the displacement vector\r\n         */\r\n        this._zeroedVertices = this.vertices.map(v => v.subtract(this.d));\r\n\r\n        super.needsDraw = true;\r\n        super.needsRender = true;\r\n    }\r\n\r\n    /**\r\n     * determine whether the point is in the object\r\n     * even/odd line intersection test against the outer edge of the line-width\r\n     * @param {number} x the x coordinate\r\n     * @param {number} y the y coordinate\r\n     * @return {boolean} whether or not the point is in the object\r\n     */\r\n    pointIsInObject(x, y) {\r\n        let inside = false;\r\n\r\n        //only bother with this check if we already know we're within the bounding box\r\n        if (super.pointIsInObject(x, y)) {\r\n            //create a line that travels from this point in any direction\r\n            //if it intersects the polygon an odd number of times, it is inside\r\n\r\n            //a line can be described by a vertex and a direction\r\n            let l = new Line(new Vector([x, y]), new Vector([1, 0]));\r\n\r\n            let compoundScale = this.compoundScale;\r\n            let offset = this.offset;\r\n\r\n            for (let i = 0; i < this._zeroedVertices.length; i++) {\r\n                let j = (i + 1) >= this._zeroedVertices.length ? 0 : i + 1;\r\n\r\n                //TODO: reimplement scaling\r\n                let v = _scaleVectorXY(this._zeroedVertices[i], compoundScale.scaleWidth, compoundScale.scaleHeight)\r\n                    .add(offset);\r\n\r\n                let w = _scaleVectorXY(this._zeroedVertices[j], compoundScale.scaleWidth, compoundScale.scaleHeight)\r\n                    .add(offset);\r\n\r\n                //for some reason, the below doesn't work\r\n                //let v = this._zeroedVertices[i].add(offset);\r\n\r\n                //let w = this._zeroedVertices[j].add(offset);\r\n\r\n\r\n                //TODO: determine how to account for lineWidths.\r\n                //it becomes complicated to determine which side of\r\n                //the line forms the outside edge unless you already\r\n                //know you're \"inside\" the polygon path\r\n                let edgeDirection = Vector.subtract(w, v).normalize();\r\n                let edge = new Line(v, edgeDirection);\r\n                let intersection = edge.intersectionWith(l);\r\n\r\n                //if the lines are parallel/colocated, no need to count;\r\n                if (intersection === null) {\r\n                    continue;\r\n                }\r\n\r\n                //TODO: should replace 0s with epsilons, where epsilon is\r\n                //the threshhold for considering two things as touching/intersecting\r\n                let intersectToTheRight = intersection.x - x >= Number.EPSILON;\r\n\r\n                //if the intersection is not to the right, no need to count\r\n                if (!intersectToTheRight) {\r\n                    continue;\r\n                }\r\n\r\n                let negativeX = (edgeDirection.x < -Number.EPSILON);\r\n                let negativeY = (edgeDirection.y < -Number.EPSILON);\r\n\r\n                //technically speaking, bottom and top should be reversed,\r\n                //since y=0 is the top left corner of the screen - it's\r\n                //just easier to think about it mathematically this way\r\n                let leftVertex = negativeX ? w : v;\r\n                let rightVertex = negativeX ? v : w;\r\n                let topVertex = negativeY ? w : v;\r\n                let bottomVertex = negativeY ? v : w;\r\n\r\n                let intersectWithinSegment =\r\n                    (intersection.x - leftVertex.x >= Number.EPSILON) &&\r\n                    (rightVertex.x - intersection.x >= Number.EPSILON) &&\r\n                    (intersection.y - topVertex.y >= Number.EPSILON) &&\r\n                    (bottomVertex.y - intersection.y >= Number.EPSILON);\r\n\r\n                if (intersectWithinSegment) {\r\n                    inside = !inside;\r\n                }\r\n            }\r\n        }\r\n        return inside;\r\n    }\r\n\r\n    /**\r\n     * override the render function for drawing vector paths specifically\r\n     * @override\r\n     */\r\n    render() {\r\n        let boundingBox = this.boundingBox;\r\n        let offset = this.offset;\r\n        let compoundScale = this.compoundScale;\r\n        //zero the vertices (left- and top-most x/y-values should be 0 and 0)\r\n        //TODO: reimplement scaling\r\n        let pathToDraw = this._zeroedVertices.map(vertex =>\r\n            vertex.subtract(new Vector([boundingBox.left, boundingBox.top])).add(offset));\r\n        drawPath(pathToDraw, this._prerenderingContext, this.style);\r\n    };\r\n}\r\n\r\n\r\n//for scaling a vector\r\n//TODO: reimplement scaling\r\n/**\r\n * scale the vectors\r\n * @param {object} vector the vector to scale\r\n * @param {number} scaleX the amount to scale the x component of the vector\r\n * @param {number} scaleY the amount to scale the y component of the vector\r\n */\r\nfunction _scaleVectorXY(vector, scaleX, scaleY) {\r\n    return new Vector([vector.x * scaleX, vector.y * scaleY]);\r\n}\r\n"],"file":"VectorPath.js"}