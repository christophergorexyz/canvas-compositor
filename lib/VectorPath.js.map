{"version":3,"sources":["../src/VectorPath.js"],"names":["VectorPath","options","vertices","map","v","Vector","x","y","yCoordinates","xCoordinates","_left","Math","min","apply","_top","_right","max","_bottom","normalizationVector","d","_normalizedVertices","subtract","_normalizedBoundingBox","inside","l","Line","compoundScale","offset","i","length","j","scaleVectorXY","scaleWidth","scaleHeight","add","w","edgeDirection","normalize","edge","intersection","intersectionWith","intersectToTheRight","negativeX","negativeY","leftVertex","rightVertex","topVertex","bottomVertex","intersectWithinSegment","boundingBox","pathToDraw","vertex","left","top","Renderer","drawPath","_prerenderingContext","style","right","bottom","lineWidth","PrimitiveComponent","vector","scaleX","scaleY"],"mappings":"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","sourcesContent":["import { Renderer } from './Renderer';\nimport { PrimitiveComponent } from './PrimitiveComponent';\nimport { Vector } from 'vectorious';\nimport { Line } from './Line';\n\n//would name the file 'path', but damn near everything\n//relies on the filesystem 'path' module\n\n/**\n * An ordered set of vectors defining a path\n */\nexport class VectorPath extends PrimitiveComponent {\n    /**\n     * see PrimitiveComponent for more options\n     * @param {Object} options the options for the object\n     * @param {Object[]} options.vertices the vertices\n     * @param {number} options.vertices[].x the y coordinate for a vertex\n     * @param {number} options.vertices[].y the y coordinate for a vertex\n     */\n    constructor(options) {\n        super(options);\n\n        options.vertices = options.vertices || [];\n\n        //this.unscaledLineWidth = this.style.lineWidth;\n\n        /**\n         * the list of vertices as vectorious Vectors\n         * @type {Vector[]} vertices\n         */\n        this.vertices = options.vertices.map(v => new Vector([v.x, v.y]));\n\n        let yCoordinates = this.vertices.map(v => v.y);\n        let xCoordinates = this.vertices.map(v => v.x);\n\n        //uses `apply` so we can supply the list as a list of arguments\n        this._left = Math.min.apply(null, xCoordinates);\n        this._top = Math.min.apply(null, yCoordinates);\n        this._right = Math.max.apply(null, xCoordinates);\n        this._bottom = Math.max.apply(null, yCoordinates);\n\n        super.d = new Vector([this._left, this._top]);\n\n        let normalizationVector = this.d;\n\n        this._normalizedVertices = this.vertices.map(v => v.subtract(normalizationVector));\n\n        this._normalizedBoundingBox = null;\n    }\n\n    /**\n     * get the bounding box for the vertices\n     * @type {{top:number, left: number, bottom:number, right:number}} boundingBox\n     */\n    get boundingBox() {\n        this._normalizedBoundingBox = {\n            top: 0,\n            left: 0,\n            right: this._right - this._left,\n            bottom: this._bottom - this._top\n        };\n\n        return {\n            top: (this._normalizedBoundingBox.top * this.compoundScale.scaleHeight) + this.offset.y - this.style.lineWidth,\n            left: (this._normalizedBoundingBox.left * this.compoundScale.scaleWidth) + this.offset.x - this.style.lineWidth,\n            bottom: (this._normalizedBoundingBox.bottom * this.compoundScale.scaleHeight) + this.offset.y + this.style.lineWidth,\n            right: (this._normalizedBoundingBox.right * this.compoundScale.scaleWidth) + this.offset.x + this.style.lineWidth\n        };\n    }\n\n\n    /**\n     * determine whether the point is in the object\n     * even/odd line intersection test\n     * @param {number} x the x coordinate\n     * @param {number} y the y coordinate\n     * @return {boolean} whether or not the point is in the object\n     */\n    pointIsInObject(x, y) {\n        let inside = false;\n        if (super.pointIsInObject(x, y)) {\n            //create a line that travels from this point in any direction\n            //if it intersects the polygon an odd number of times, it is inside\n\n            //a line can be described as a vertex and a direction\n            let l = new Line(new Vector([x, y]), new Vector([1, 0]));\n\n            let compoundScale = this.compoundScale;\n            let offset = this.offset;\n\n            for (let i = 0; i < this._normalizedVertices.length; i++) {\n                let j = (i + 1) >= this._normalizedVertices.length ? 0 : i + 1;\n\n                let v = scaleVectorXY(this._normalizedVertices[i], compoundScale.scaleWidth, compoundScale.scaleHeight)\n                    .add(offset);\n\n                let w = scaleVectorXY(this._normalizedVertices[j], compoundScale.scaleWidth, compoundScale.scaleHeight)\n                    .add(offset);\n\n                let edgeDirection = Vector.subtract(w, v).normalize();\n                let edge = new Line(v, edgeDirection);\n                let intersection = edge.intersectionWith(l);\n\n                //if the lines are parallel/colocated, no need to count;\n                if (intersection === null) {\n                    continue;\n                }\n\n                //TODO: should replace 0s with epsilons, where epsilon is\n                //the threshhold for considering two things as touching/intersecting\n                let intersectToTheRight = intersection.x - x >= 0;\n\n                //if the intersection is not to the right, no need to count\n                if (!intersectToTheRight) {\n                    continue;\n                }\n\n                let negativeX = (edgeDirection.x < 0);\n                let negativeY = (edgeDirection.y < 0);\n\n                //technically speaking, bottom and top should be reversed,\n                //since y=0 is the top left corner of the screen - it's\n                //just easier to think about it mathematically this way\n                let leftVertex = negativeX ? w : v;\n                let rightVertex = negativeX ? v : w;\n                let topVertex = negativeY ? w : v;\n                let bottomVertex = negativeY ? v : w;\n\n                let intersectWithinSegment =\n                    (intersection.x - leftVertex.x >= 0) &&\n                    (rightVertex.x - intersection.x >= 0) &&\n                    (intersection.y - topVertex.y >= 0) &&\n                    (bottomVertex.y - intersection.y >= 0);\n\n                if (intersectWithinSegment) {\n                    inside = !inside;\n                }\n            }\n        }\n        return inside;\n    }\n\n    /**\n     * override the render function for drawing vector paths specifically\n     * @override\n     */\n    render() {\n        let boundingBox = this.boundingBox;\n        let offset = this.offset;\n        let compoundScale = this.compoundScale;\n        //normalize the vertices (left- and top-most x/y-values should be 0 and 0)\n        let pathToDraw = this._normalizedVertices.map(vertex =>\n            scaleVectorXY(vertex, compoundScale.scaleWidth, compoundScale.scaleHeight)\n            .subtract(new Vector([boundingBox.left, boundingBox.top]))\n            .add(offset));\n        Renderer.drawPath(pathToDraw, this._prerenderingContext, this.style);\n    };\n}\n\nfunction scaleVectorXY(vector, scaleX, scaleY) {\n    return new Vector([vector.x * scaleX, vector.y * scaleY]);\n}\n"],"file":"VectorPath.js"}