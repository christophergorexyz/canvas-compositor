{"version":3,"sources":["../src/VectorPath.js"],"names":["VectorPath","options","_vertices","vertices","_zeroedBoundingBox","top","left","right","_right","_left","bottom","_bottom","_top","offset","y","style","lineWidth","x","verts","map","v","Vector","yCoordinates","xCoordinates","Math","min","apply","max","_zeroedVertices","subtract","d","inside","l","Line","compoundScale","i","length","j","_scaleVectorXY","scaleWidth","scaleHeight","add","w","edgeDirection","normalize","edge","intersection","intersectionWith","intersectToTheRight","Number","EPSILON","negativeX","negativeY","leftVertex","rightVertex","topVertex","bottomVertex","intersectWithinSegment","boundingBox","pathToDraw","vertex","_prerenderingContext","PrimitiveComponent","vector","scaleX","scaleY"],"mappings":"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","sourcesContent":["\nimport { Vector } from 'vectorious';\nimport PrimitiveComponent from './PrimitiveComponent';\nimport { drawPath } from './Renderer';\nimport Line from './Line';\n\n//would name the file 'path', but damn near everything\n//relies on the filesystem 'path' module\n\n/**\n * An ordered set of vectors defining a path\n */\nexport default class VectorPath extends PrimitiveComponent {\n  /**\n   * see PrimitiveComponent for more options\n   * @param {Object} options the options for the object\n   * @param {Object[]} options.vertices the vertices\n   * @param {number} options.vertices[].x the y coordinate for a vertex\n   * @param {number} options.vertices[].y the y coordinate for a vertex\n   */\n  constructor(options) {\n    super(options);\n\n    /**\n     * The sequence of vertices in the path\n     */\n    this._vertices = [];\n    this.vertices = options.vertices || [];\n\n    //this.unscaledLineWidth = this.style.lineWidth;\n\n    /**\n     * A zeroed bounding box where (left, top) is (0, 0)\n     */\n    this._zeroedBoundingBox = null;\n  }\n\n  /**\n   * get the bounding box for the vertices in the path\n   * @type {{top:number, left: number, bottom:number, right:number}} boundingBox\n   * @property {number} top the coordinate of the top edge of the bounding box\n   * @property {number} left the coordinate of the left edge of the bounding box\n   * @property {number} right the coordinate of the right edge of the bounding box\n   * @property {number} bottom the coordinate of the bottom edge of the bounding box\n   */\n  get boundingBox() {\n    /**\n     * The bounding box zeroed\n     * @property {number} top always 0\n     * @property {number} left always 0\n     * @property {number} right the distance from the leftmost vector to the rightmost\n     * @property {number} bottom the distance from the topmost vector to the bottommost\n     */\n    this._zeroedBoundingBox = {\n      top: 0,\n      left: 0,\n      right: this._right - this._left,\n      bottom: this._bottom - this._top\n    };\n\n    //TODO: reimplement scaling\n    return {\n      top: this._zeroedBoundingBox.top + this.offset.y - this.style.lineWidth,\n      left: this._zeroedBoundingBox.left + this.offset.x - this.style.lineWidth,\n      bottom: this._zeroedBoundingBox.bottom + this.offset.y + this.style.lineWidth,\n      right: this._zeroedBoundingBox.right + this.offset.x + this.style.lineWidth\n    };\n  }\n\n  /**\n   * retrieve the list of vertices\n   * @type {Array<{x: number, y: number }>} the sequence of vertices in the path\n   */\n  get vertices() {\n    return this._vertices;\n  }\n\n  /**\n   * set the list of vertices\n   * @param {Array<{x: number, y: number }>} verts The list of vertices to be used\n   */\n  set vertices(verts) {\n    /**\n     * the list of vertices as vectorious Vectors\n     * @type {object[]} vertices\n     */\n    this._vertices = verts.map(v => new Vector([v.x, v.y]));\n\n    let yCoordinates = this.vertices.map(v => v.y);\n    let xCoordinates = this.vertices.map(v => v.x);\n\n    //uses `apply` so we can supply the list as a list of arguments\n    /**\n     * @type {number} the leftmost x-coordinate\n     */\n    this._left = Math.min.apply(null, xCoordinates);\n\n    /**\n     * @type {number} the topmost y-coordinate\n     */\n    this._top = Math.min.apply(null, yCoordinates);\n\n    /**\n     * @type {number} the rightmost x-coordinate\n     */\n    this._right = Math.max.apply(null, xCoordinates);\n\n    /**\n     * @type {number} the bottommost y-coordinate\n     */\n    this._bottom = Math.max.apply(null, yCoordinates);\n\n    super.d = new Vector([this._left, this._top]);\n\n    /**\n     * Vertices zeroed against the displacement vector\n     */\n    this._zeroedVertices = this.vertices.map(v => v.subtract(this.d));\n\n    super.needsDraw = true;\n    super.needsRender = true;\n  }\n\n  /**\n   * determine whether the point is in the object\n   * even/odd line intersection test against the outer edge of the line-width\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @return {boolean} whether or not the point is in the object\n   */\n  pointIsInObject(x, y) {\n    let inside = false;\n\n    //only bother with this check if we already know we're within the bounding box\n    if (super.pointIsInObject(x, y)) {\n      //create a line that travels from this point in any direction\n      //if it intersects the polygon an odd number of times, it is inside\n\n      //a line can be described by a vertex and a direction\n      let l = new Line(new Vector([x, y]), new Vector([1, 0]));\n\n      let compoundScale = this.compoundScale;\n      let offset = this.offset;\n\n      for (let i = 0; i < this._zeroedVertices.length; i++) {\n        let j = (i + 1) >= this._zeroedVertices.length ? 0 : i + 1;\n\n        //TODO: reimplement scaling\n        let v = _scaleVectorXY(this._zeroedVertices[i], compoundScale.scaleWidth, compoundScale.scaleHeight)\n          .add(offset);\n\n        let w = _scaleVectorXY(this._zeroedVertices[j], compoundScale.scaleWidth, compoundScale.scaleHeight)\n          .add(offset);\n\n        //for some reason, the below doesn't work\n        //let v = this._zeroedVertices[i].add(offset);\n\n        //let w = this._zeroedVertices[j].add(offset);\n\n\n        //TODO: determine how to account for lineWidths.\n        //it becomes complicated to determine which side of\n        //the line forms the outside edge unless you already\n        //know you're \"inside\" the polygon path\n        let edgeDirection = Vector.subtract(w, v).normalize();\n        let edge = new Line(v, edgeDirection);\n        let intersection = edge.intersectionWith(l);\n\n        //if the lines are parallel/colocated, no need to count;\n        if (intersection === null) {\n          continue;\n        }\n\n        //TODO: should replace 0s with epsilons, where epsilon is\n        //the threshhold for considering two things as touching/intersecting\n        let intersectToTheRight = intersection.x - x >= Number.EPSILON;\n\n        //if the intersection is not to the right, no need to count\n        if (!intersectToTheRight) {\n          continue;\n        }\n\n        let negativeX = (edgeDirection.x < -Number.EPSILON);\n        let negativeY = (edgeDirection.y < -Number.EPSILON);\n\n        //technically speaking, bottom and top should be reversed,\n        //since y=0 is the top left corner of the screen - it's\n        //just easier to think about it mathematically this way\n        let leftVertex = negativeX ? w : v;\n        let rightVertex = negativeX ? v : w;\n        let topVertex = negativeY ? w : v;\n        let bottomVertex = negativeY ? v : w;\n\n        let intersectWithinSegment =\n          (intersection.x - leftVertex.x >= Number.EPSILON) &&\n          (rightVertex.x - intersection.x >= Number.EPSILON) &&\n          (intersection.y - topVertex.y >= Number.EPSILON) &&\n          (bottomVertex.y - intersection.y >= Number.EPSILON);\n\n        if (intersectWithinSegment) {\n          inside = !inside;\n        }\n      }\n    }\n    return inside;\n  }\n\n  /**\n   * override the render function for drawing vector paths specifically\n   * @override\n   */\n  render() {\n    let boundingBox = this.boundingBox;\n    let offset = this.offset;\n    let compoundScale = this.compoundScale;\n    //zero the vertices (left- and top-most x/y-values should be 0 and 0)\n    //TODO: reimplement scaling\n    let pathToDraw = this._zeroedVertices.map(vertex =>\n      vertex.subtract(new Vector([boundingBox.left, boundingBox.top])).add(offset));\n    drawPath(pathToDraw, this._prerenderingContext, this.style);\n  };\n}\n\n\n//for scaling a vector\n//TODO: reimplement scaling\n/**\n * scale the vectors\n * @param {object} vector the vector to scale\n * @param {number} scaleX the amount to scale the x component of the vector\n * @param {number} scaleY the amount to scale the y component of the vector\n */\nfunction _scaleVectorXY(vector, scaleX, scaleY) {\n  return new Vector([vector.x * scaleX, vector.y * scaleY]);\n}\n"],"file":"VectorPath.js"}