{"version":3,"sources":["../src/Composition.js"],"names":["Composition","options","_children","children","x","y","filter","c","PointIsInObject","length","pointIsInObject","child","parent","push","addChild","index","indexOf","splice","boundingBox","offset","top","left","bottom","right","draw","_prerenderingContext","Infinity","Math","min","max","PrimitiveComponent"],"mappings":";;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;IASaA,W;;;;;AACT;;;AAGA,uBAAYC,OAAZ,EAAqB;AAAA;;AAAA;;AACjB,qFAAMA,OAAN;AACAA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA;;;;AAGA,UAAKC,SAAL,GAAiBD,OAAO,CAACE,QAAR,IAAoB,EAArC;AANiB;AAOpB;AAED;;;;;;;;;AAmCA;;;;;;+BAMWC,C,EAAGC,C,EAAG;AACb,aAAO,KAAKF,QAAL,CAAcG,MAAd,CAAqB,UAACC,CAAD;AAAA,eAAOA,CAAC,CAACC,eAAF,CAAkBJ,CAAlB,EAAqBC,CAArB,CAAP;AAAA,OAArB,CAAP;AACH;AAED;;;;;;;;;4BAMQD,C,EAAGC,C,EAAG;AACV;AACA,WAAK,IAAIE,CAAC,GAAG,KAAKJ,QAAL,CAAcM,MAAd,GAAuB,CAApC,EAAuCF,CAAC,IAAI,CAA5C,EAA+CA,CAAC,EAAhD,EAAoD;AAChD,YAAI,KAAKJ,QAAL,CAAcI,CAAd,EAAiBG,eAAjB,CAAiCN,CAAjC,EAAoCC,CAApC,CAAJ,EAA4C;AACxC,iBAAO,KAAKF,QAAL,CAAcI,CAAd,CAAP;AACH;AACJ;AACJ;AAED;;;;;;;6BAISI,K,EAAO;AACZA,MAAAA,KAAK,CAACC,MAAN,GAAe,IAAf;AACA,WAAKT,QAAL,CAAcU,IAAd,CAAmBF,KAAnB;;AACA,kEAAoB,IAApB;;AACA,gEAAkB,IAAlB,cAJY,CAKZ;AACA;AACA;AACA;AACA;;AACH;AAED;;;;;;;gCAIYR,Q,EAAS;AAAA;AAAA;AAAA;;AAAA;AACjB,6BAAcA,QAAd,8HAAuB;AAAA,cAAdI,CAAc;AACnB,eAAKO,QAAL,CAAcP,CAAd;AACH;AAHgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIpB;AAED;;;;;;;;gCAKYI,K,EAAO;AACf,UAAIA,KAAJ,EAAW;AACP,YAAII,KAAK,GAAG,KAAKZ,QAAL,CAAca,OAAd,CAAsBL,KAAtB,CAAZ;;AACA,YAAII,KAAK,IAAI,CAAb,EAAgB;AACZ,sEAAoB,IAApB;;AACA,oEAAkB,IAAlB;;AACA,iBAAO,KAAKZ,QAAL,CAAcc,MAAd,CAAqBF,KAArB,EAA4B,CAA5B,CAAP;AACH;AACJ;AACJ;;;;AAED;;;;6BAIS;AACL;AACA,UAAIG,WAAW,GAAG,KAAKA,WAAvB;AACA,UAAIC,MAAM,GAAG;AACTC,QAAAA,GAAG,EAAE,CAACF,WAAW,CAACE,GADT;AAETC,QAAAA,IAAI,EAAE,CAACH,WAAW,CAACG,IAFV;AAGTC,QAAAA,MAAM,EAAE,CAACJ,WAAW,CAACI,MAHZ;AAITC,QAAAA,KAAK,EAAE,CAACL,WAAW,CAACK;AAJX,OAAb;AAHK;AAAA;AAAA;;AAAA;AAUL,8BAAc,KAAKpB,QAAnB,mIAA6B;AAAA,cAApBI,CAAoB;AACzBA,UAAAA,CAAC,CAACiB,IAAF,CAAO,KAAKC,oBAAZ,EAAkCN,MAAlC;AACH;AAZI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYJ,OAZI,CAcL;AACA;AACA;AACA;AACA;AACA;AACH;;;wBA1Hc;AACX,aAAO,KAAKjB,SAAZ;AACH;AAED;;;;;;;wBAIkB;AACd,UAAIkB,GAAG,GAAGM,QAAV;AAAA,UACIL,IAAI,GAAGK,QADX;AAAA,UAEIJ,MAAM,GAAG,CAACI,QAFd;AAAA,UAGIH,KAAK,GAAG,CAACG,QAHb;AADc;AAAA;AAAA;;AAAA;AAMd,8BAAc,KAAKvB,QAAnB,mIAA6B;AAAA,cAApBI,CAAoB;AACzB,cAAIW,WAAW,GAAGX,CAAC,CAACW,WAApB;AACAE,UAAAA,GAAG,GAAGO,IAAI,CAACC,GAAL,CAASV,WAAW,CAACE,GAArB,EAA0BA,GAA1B,CAAN;AACAC,UAAAA,IAAI,GAAGM,IAAI,CAACC,GAAL,CAASV,WAAW,CAACG,IAArB,EAA2BA,IAA3B,CAAP;AACAC,UAAAA,MAAM,GAAGK,IAAI,CAACE,GAAL,CAASX,WAAW,CAACI,MAArB,EAA6BA,MAA7B,CAAT;AACAC,UAAAA,KAAK,GAAGI,IAAI,CAACE,GAAL,CAASX,WAAW,CAACK,KAArB,EAA4BA,KAA5B,CAAR;AACH;AAZa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYb;AAED,aAAO;AACHH,QAAAA,GAAG,EAAEA,GADF;AAEHC,QAAAA,IAAI,EAAEA,IAFH;AAGHC,QAAAA,MAAM,EAAEA,MAHL;AAIHC,QAAAA,KAAK,EAAEA;AAJJ,OAAP;AAMH;;;;EA7C4BO,uC","sourcesContent":["import { PrimitiveComponent } from './PrimitiveComponent';\n\n/**\n * The Composition class is an extension of the Primitive that is\n * composed of other extensions of the Primitive. The Composition\n * is used to establish the Scene graph as the parent of all other\n * objects on screen. This is the key abstraction of the [composite\n * pattern](https://en.wikipedia.org/wiki/Composite_pattern): an\n * action taken on the parent element acts upon all of the children,\n * and transatively, all of their children.\n */\nexport class Composition extends PrimitiveComponent {\n    /**\n     * @param {object} options object settings\n     */\n    constructor(options) {\n        super(options);\n        options = options || {};\n        /**\n         * The children of this composition\n         */\n        this._children = options.children || [];\n    }\n\n    /**\n     * children of this composition\n     * @type {Array} children the which compose this object\n     */\n    get children() {\n        return this._children;\n    }\n\n    /**\n     * the bounding box of the composition (i.e., the containing bounds of all the children of this composition)\n     * @type {{top:number, left:number, right:number, bottom:number}} boundingBox\n     */\n    get boundingBox() {\n        let top = Infinity,\n            left = Infinity,\n            bottom = -Infinity,\n            right = -Infinity;\n\n        for (let c of this.children) {\n            let boundingBox = c.boundingBox;\n            top = Math.min(boundingBox.top, top);\n            left = Math.min(boundingBox.left, left);\n            bottom = Math.max(boundingBox.bottom, bottom);\n            right = Math.max(boundingBox.right, right);\n        };\n\n        return {\n            top: top,\n            left: left,\n            bottom: bottom,\n            right: right\n        };\n    }\n\n\n    /**\n     * the an array of children that are found at (x, y)\n     * @return {object} childrenAt all the children below the point\n     * @param {number} x the x coordinate\n     * @param {number} y the y coordinate\n     */\n    childrenAt(x, y) {\n        return this.children.filter((c) => c.PointIsInObject(x, y));\n    }\n\n    /**\n     * get the top-most child at the (x, y)\n     * @return {object} childAt the first child below the point\n     * @param {number} x the x coordinate\n     * @param {number} y the y coordinate\n     */\n    childAt(x, y) {\n        //loop over the children in reverse because drawing order\n        for (var c = this.children.length - 1; c >= 0; c--) {\n            if (this.children[c].pointIsInObject(x, y)) {\n                return this.children[c];\n            }\n        }\n    }\n\n    /**\n     * add a child to this composition\n     * @param {object} child the child to be added\n     */\n    addChild(child) {\n        child.parent = this;\n        this.children.push(child);\n        super.needsRender = true;\n        super.needsDraw = true;\n        //TODO: make this hook more generic\n        //by using a registry\n        //if (this.onchildadded) {\n        //  this.onchildadded();\n        //}\n    }\n\n    /**\n     * add multiple children to the composition\n     * @param {object} children the list of children to be added\n     */\n    addChildren(children){\n        for (let c of children){\n            this.addChild(c);\n        }\n    }\n\n    /**\n     * remove a child from this composition\n     * @param {object} child the child to be removed\n     * @return {object} the child removed\n     */\n    removeChild(child) {\n        if (child) {\n            var index = this.children.indexOf(child);\n            if (index >= 0) {\n                super.needsRender = true;\n                super.needsDraw = true;\n                return this.children.splice(index, 1);\n            }\n        }\n    };\n\n    /**\n     * @override\n     * override the render functiont to render the children onto this compositions prerendering canvas\n     */\n    render() {\n        // required to make sure that the drawing occurs within the bounds of this composition\n        let boundingBox = this.boundingBox;\n        var offset = {\n            top: -boundingBox.top,\n            left: -boundingBox.left,\n            bottom: -boundingBox.bottom,\n            right: -boundingBox.right\n        };\n\n        for (let c of this.children) {\n            c.draw(this._prerenderingContext, offset);\n        };\n\n        // `destination-out` will erase things\n        //this._prerenderingContext.globalCompositeOperation = 'destination-out';\n        //_.each(this.masks, function (m) {\n        //m.draw(renderContext, contextOffset);\n        //});\n        //renderContext.globalCompositeOperation = 'normal';\n    };\n}\n"],"file":"Composition.js"}