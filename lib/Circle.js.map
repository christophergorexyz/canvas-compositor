{"version":3,"sources":["../src/Circle.js"],"names":["Circle","options","radius","scale","compoundScale","lineWidth","style","Renderer","drawCircle","scaleWidth","scaleHeight","_prerenderingContext","x","y","offset","a","b","c","top","left","bottom","right","PrimitiveComponent"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;AAEA;;;IAGaA,M;;;;;AACT;;AACA;;;;AAIA,kBAAYC,OAAZ,EAAqB;AAAA;;AAAA;;AACjB,gFAAMA,OAAN;AACA;;;;;AAIA,UAAKC,MAAL,GAAcD,OAAO,CAACC,MAAR,IAAkB,CAAhC;AANiB;AAOpB;AAED;;;;;;;;;AA+BA;;;;6BAIS;AACL;AACA,UAAIC,KAAK,GAAG,KAAKC,aAAjB;AACA,UAAIC,SAAS,GAAG,KAAKC,KAAL,CAAWD,SAA3B;;AACAE,yBAASC,UAAT,CACK,KAAKN,MAAL,GAAcC,KAAK,CAACM,UAArB,GAAmCJ,SADvC,EAEK,KAAKH,MAAL,GAAcC,KAAK,CAACO,WAArB,GAAoCL,SAFxC,EAGK,KAAKH,MAAL,GAAcC,KAAK,CAACM,UAHzB,EAII,KAAKE,oBAJT,EAKI,KAAKL,KALT;AAOH;AAED;;;;;;;;;;oCAOgBM,C,EAAGC,C,EAAG;AAElB,UAAIC,MAAM,GAAG,KAAKA,MAAlB,CAFkB,CAIlB;AACA;;AACI,UAAIC,CAAC,GAAGH,CAAC,GAAGE,MAAM,CAACF,CAAnB;AACA,UAAII,CAAC,GAAGH,CAAC,GAAGC,MAAM,CAACD,CAAnB;AACA,UAAII,CAAC,GAAG,KAAKf,MAAb,CARc,CAUd;;AACA,aAAQa,CAAC,GAAGA,CAAL,GAAWC,CAAC,GAAGA,CAAf,IAAsBC,CAAC,GAAGA,CAAjC,CAXc,CAYlB;;AACA;;;;;AAKH;;;wBArEiB;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIH,MAAM,GAAG,KAAKA,MAAlB;AACA,UAAIX,KAAK,GAAG,KAAKC,aAAjB;AACA,aAAO;AACHc,QAAAA,GAAG,EAAEJ,MAAM,CAACD,CAAP,IACC,KAAKX,MAAL,GAAcC,KAAK,CAACO,WAArB,GACI,KAAKJ,KAAL,CAAWD,SAFf,CADF;AAIHc,QAAAA,IAAI,EAAEL,MAAM,CAACF,CAAP,IACA,KAAKV,MAAL,GAAcC,KAAK,CAACM,UAArB,GACI,KAAKH,KAAL,CAAWD,SAFd,CAJH;AAOHe,QAAAA,MAAM,EAAEN,MAAM,CAACD,CAAP,GACH,KAAKX,MAAL,GAAcC,KAAK,CAACO,WADjB,GAEH,KAAKJ,KAAL,CAAWD,SATb;AAUHgB,QAAAA,KAAK,EAAEP,MAAM,CAACF,CAAP,GACF,KAAKV,MAAL,GAAcC,KAAK,CAACM,UADlB,GAEF,KAAKH,KAAL,CAAWD;AAZb,OAAP;AAcH;;;;EA5CuBiB,uC","sourcesContent":["import { Renderer } from './Renderer';\nimport { PrimitiveComponent } from './PrimitiveComponent';\n\n/**\n * A circle\n */\nexport class Circle extends PrimitiveComponent {\n    //TODO: provide details about options for docs - link to a separate page\n    /**\n     * PrimitiveComponent constructor\n     * @param {object} options object settings\n     */\n    constructor(options) {\n        super(options)\n        /**\n         * the radius of the circle\n         * @type {number} radius\n         */\n        this.radius = options.radius || 0;\n    }\n\n    /**\n     * get the bounding box of the circle;\n     * @type {{top:number, left: number, bottom:number, right:number}}\n     */\n    get boundingBox() {\n        //TODO: possibly memory-inefficient - need to research:\n        //strokes are (were?) centered over the mathematical perimeter -\n        //so half the stroke laid within the perimeter, and the\n        //other half laid outside. for some reason, this doesn't\n        //work for (0 < lineWidth < 2.0).\n        //\n        //it's just a pixel, but when a thousand objects are on screen,\n        //that'll make a difference\n        let offset = this.offset;\n        let scale = this.compoundScale;\n        return {\n            top: offset.y -\n                ((this.radius * scale.scaleHeight) +\n                    (this.style.lineWidth)),\n            left: offset.x -\n                ((this.radius * scale.scaleWidth) +\n                    (this.style.lineWidth)),\n            bottom: offset.y +\n                (this.radius * scale.scaleHeight) +\n                (this.style.lineWidth),\n            right: offset.x +\n                (this.radius * scale.scaleWidth) +\n                (this.style.lineWidth)\n        };\n    }\n\n    /**\n     * override the render function for drawing circles specifically\n     * @override\n     */\n    render() {\n        //the below is to ensure the proper placement when scaling/line widths are accounted for\n        let scale = this.compoundScale;\n        let lineWidth = this.style.lineWidth;\n        Renderer.drawCircle(\n            (this.radius * scale.scaleWidth) + lineWidth,\n            (this.radius * scale.scaleHeight) + lineWidth,\n            (this.radius * scale.scaleWidth),\n            this._prerenderingContext,\n            this.style\n        );\n    }\n\n    /**\n     * determine whether the point is in the object\n     * basically just the pythagorean theorem\n     * @param {number} x the x coordinate\n     * @param {number} y the y coordinate\n     * @return {boolean} whether or not the point is in the object\n     */\n    pointIsInObject(x, y) {\n\n        let offset = this.offset;\n\n        //don't bother checking the bounding box because\n        //pythagorean formula is closed-form\n            let a = x - offset.x;\n            let b = y - offset.y;\n            let c = this.radius;\n\n            //thanks pythagoras~!\n            return (a * a) + (b * b) <= (c * c);\n        //use the below when scaling is reimplemented\n        /*\n\t\treturn (\n\t\t\tCanvasObject.prototype.PointIsInObject.call(this, x, y) &&\n\t\t\tMath.pow((x - this.offset.x), 2) / Math.pow((this.radius * this.GlobalScale.scaleWidth), 2) + Math.pow((y - this.offset.y), 2) / Math.pow((this.radius * this.GlobalScale.scaleHeight), 2) <= 1\n\t\t);*/\n    };\n}\n"],"file":"Circle.js"}