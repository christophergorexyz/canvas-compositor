{"version":3,"sources":["../src/Circle.js"],"names":["Circle","options","radius","offset","scale","compoundScale","top","y","scaleHeight","style","lineWidth","left","x","scaleWidth","bottom","right","_prerenderingContext","a","b","c","PrimitiveComponent"],"mappings":";;;;;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;IACaA,M;;;;;AACX;;AACA;AACF;AACA;AACA;AACE,kBAAYC,OAAZ,EAAqB;AAAA;;AAAA;;AACnB,8BAAMA,OAAN;AACA;AACJ;AACA;AACA;;AACI,UAAKC,MAAL,GAAcD,OAAO,CAACC,MAAR,IAAkB,CAAhC;AANmB;AAOpB;AAED;AACF;AACA;AACA;;;;;SACE,eAAkB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIC,MAAM,GAAG,KAAKA,MAAlB;AACA,UAAIC,KAAK,GAAG,KAAKC,aAAjB;AACA,aAAO;AACLC,QAAAA,GAAG,EAAEH,MAAM,CAACI,CAAP,IACO,KAAKL,MAAL,GAAcE,KAAK,CAACI,WAArB,GACI,KAAKC,KAAL,CAAWC,SAFrB,CADA;AAILC,QAAAA,IAAI,EAAER,MAAM,CAACS,CAAP,IACM,KAAKV,MAAL,GAAcE,KAAK,CAACS,UAArB,GACI,KAAKJ,KAAL,CAAWC,SAFpB,CAJD;AAOLI,QAAAA,MAAM,EAAEX,MAAM,CAACI,CAAP,GACG,KAAKL,MAAL,GAAcE,KAAK,CAACI,WADvB,GAEG,KAAKC,KAAL,CAAWC,SATjB;AAULK,QAAAA,KAAK,EAAEZ,MAAM,CAACS,CAAP,GACI,KAAKV,MAAL,GAAcE,KAAK,CAACS,UADxB,GAEI,KAAKJ,KAAL,CAAWC;AAZjB,OAAP;AAcD;AAED;AACF;AACA;AACA;;;;WACE,kBAAS;AACP;AACA,UAAIN,KAAK,GAAG,KAAKC,aAAjB;AACA,UAAIK,SAAS,GAAG,KAAKD,KAAL,CAAWC,SAA3B;AACA,gCACG,KAAKR,MAAL,GAAcE,KAAK,CAACS,UAArB,GAAmCH,SADrC,EAEG,KAAKR,MAAL,GAAcE,KAAK,CAACI,WAArB,GAAoCE,SAFtC,EAGG,KAAKR,MAAL,GAAcE,KAAK,CAACS,UAHvB,EAIE,KAAKG,oBAJP,EAKE,KAAKP,KALP;AAOD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,yBAAgBG,CAAhB,EAAmBL,CAAnB,EAAsB;AAEpB,UAAIJ,MAAM,GAAG,KAAKA,MAAlB,CAFoB,CAIpB;AACA;;AACA,UAAIc,CAAC,GAAGL,CAAC,GAAGT,MAAM,CAACS,CAAnB;AACA,UAAIM,CAAC,GAAGX,CAAC,GAAGJ,MAAM,CAACI,CAAnB;AACA,UAAIY,CAAC,GAAG,KAAKjB,MAAb,CARoB,CAUpB;;AACA,aAAQe,CAAC,GAAGA,CAAL,GAAWC,CAAC,GAAGA,CAAf,IAAsBC,CAAC,GAAGA,CAAjC,CAXoB,CAYpB;;AACA;AACJ;AACA;AACA;AACA;AACG;;;;EAxFyBC,uC","sourcesContent":["import { drawCircle } from './Renderer';\nimport { PrimitiveComponent } from './PrimitiveComponent';\n\n/**\n * A circle\n */\nexport class Circle extends PrimitiveComponent {\n  //TODO: provide details about options for docs - link to a separate page\n  /**\n   * PrimitiveComponent constructor\n   * @param {object} options object settings\n   */\n  constructor(options) {\n    super(options);\n    /**\n     * the radius of the circle\n     * @type {number}\n     */\n    this.radius = options.radius || 0;\n  }\n\n  /**\n   * get the bounding box of the circle;\n   * @type {{top:number, left: number, bottom:number, right:number}}\n   */\n  get boundingBox() {\n    //TODO: possibly memory-inefficient - need to research:\n    //strokes are (were?) centered over the mathematical perimeter -\n    //so half the stroke laid within the perimeter, and the\n    //other half laid outside. for some reason, this doesn't\n    //work for (0 < lineWidth < 2.0).\n    //\n    //it's just a pixel, but when a thousand objects are on screen,\n    //that'll make a difference\n    let offset = this.offset;\n    let scale = this.compoundScale;\n    return {\n      top: offset.y -\n                ((this.radius * scale.scaleHeight) +\n                    (this.style.lineWidth)),\n      left: offset.x -\n                ((this.radius * scale.scaleWidth) +\n                    (this.style.lineWidth)),\n      bottom: offset.y +\n                (this.radius * scale.scaleHeight) +\n                (this.style.lineWidth),\n      right: offset.x +\n                (this.radius * scale.scaleWidth) +\n                (this.style.lineWidth)\n    };\n  }\n\n  /**\n   * override the render function for drawing circles specifically\n   * @override\n   */\n  render() {\n    //the below is to ensure the proper placement when scaling/line widths are accounted for\n    let scale = this.compoundScale;\n    let lineWidth = this.style.lineWidth;\n    drawCircle(\n      (this.radius * scale.scaleWidth) + lineWidth,\n      (this.radius * scale.scaleHeight) + lineWidth,\n      (this.radius * scale.scaleWidth),\n      this._prerenderingContext,\n      this.style\n    );\n  }\n\n  /**\n   * determine whether the point is in the object\n   * basically just the pythagorean theorem\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @return {boolean} whether or not the point is in the object\n   */\n  pointIsInObject(x, y) {\n\n    let offset = this.offset;\n\n    //don't bother checking the bounding box because\n    //pythagorean formula is closed-form\n    let a = x - offset.x;\n    let b = y - offset.y;\n    let c = this.radius;\n\n    //thanks pythagoras~!\n    return (a * a) + (b * b) <= (c * c);\n    //use the below when scaling is reimplemented\n    /*\n\t\treturn (\n\t\t\tCanvasObject.prototype.PointIsInObject.call(this, x, y) &&\n\t\t\tMath.pow((x - this.offset.x), 2) / Math.pow((this.radius * this.GlobalScale.scaleWidth), 2) + Math.pow((y - this.offset.y), 2) / Math.pow((this.radius * this.GlobalScale.scaleHeight), 2) <= 1\n\t\t);*/\n  }\n}\n"],"file":"Circle.js"}