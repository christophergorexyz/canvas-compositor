{"version":3,"sources":["../src/Circle.js"],"names":["Circle","options","radius","scale","compoundScale","lineWidth","style","scaleWidth","scaleHeight","_prerenderingContext","x","y","offset","a","b","c","top","left","bottom","right","PrimitiveComponent"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;AAEA;;;IAGaA,M;;;;;AACT;;AACA;;;;AAIA,kBAAYC,OAAZ,EAAqB;AAAA;;AAAA;;AACjB,gFAAMA,OAAN;AACA;;;;;AAIA,UAAKC,MAAL,GAAcD,OAAO,CAACC,MAAR,IAAkB,CAAhC;AANiB;AAOpB;AAED;;;;;;;;;AA+BA;;;;6BAIS;AACL;AACA,UAAIC,KAAK,GAAG,KAAKC,aAAjB;AACA,UAAIC,SAAS,GAAG,KAAKC,KAAL,CAAWD,SAA3B;AACA,gCACK,KAAKH,MAAL,GAAcC,KAAK,CAACI,UAArB,GAAmCF,SADvC,EAEK,KAAKH,MAAL,GAAcC,KAAK,CAACK,WAArB,GAAoCH,SAFxC,EAGK,KAAKH,MAAL,GAAcC,KAAK,CAACI,UAHzB,EAII,KAAKE,oBAJT,EAKI,KAAKH,KALT;AAOH;AAED;;;;;;;;;;oCAOgBI,C,EAAGC,C,EAAG;AAElB,UAAIC,MAAM,GAAG,KAAKA,MAAlB,CAFkB,CAIlB;AACA;;AACI,UAAIC,CAAC,GAAGH,CAAC,GAAGE,MAAM,CAACF,CAAnB;AACA,UAAII,CAAC,GAAGH,CAAC,GAAGC,MAAM,CAACD,CAAnB;AACA,UAAII,CAAC,GAAG,KAAKb,MAAb,CARc,CAUd;;AACA,aAAQW,CAAC,GAAGA,CAAL,GAAWC,CAAC,GAAGA,CAAf,IAAsBC,CAAC,GAAGA,CAAjC,CAXc,CAYlB;;AACA;;;;;AAKH;;;wBArEiB;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIH,MAAM,GAAG,KAAKA,MAAlB;AACA,UAAIT,KAAK,GAAG,KAAKC,aAAjB;AACA,aAAO;AACHY,QAAAA,GAAG,EAAEJ,MAAM,CAACD,CAAP,IACC,KAAKT,MAAL,GAAcC,KAAK,CAACK,WAArB,GACI,KAAKF,KAAL,CAAWD,SAFf,CADF;AAIHY,QAAAA,IAAI,EAAEL,MAAM,CAACF,CAAP,IACA,KAAKR,MAAL,GAAcC,KAAK,CAACI,UAArB,GACI,KAAKD,KAAL,CAAWD,SAFd,CAJH;AAOHa,QAAAA,MAAM,EAAEN,MAAM,CAACD,CAAP,GACH,KAAKT,MAAL,GAAcC,KAAK,CAACK,WADjB,GAEH,KAAKF,KAAL,CAAWD,SATb;AAUHc,QAAAA,KAAK,EAAEP,MAAM,CAACF,CAAP,GACF,KAAKR,MAAL,GAAcC,KAAK,CAACI,UADlB,GAEF,KAAKD,KAAL,CAAWD;AAZb,OAAP;AAcH;;;;EA5CuBe,uC","sourcesContent":["import { drawCircle } from './Renderer';\r\nimport { PrimitiveComponent } from './PrimitiveComponent';\r\n\r\n/**\r\n * A circle\r\n */\r\nexport class Circle extends PrimitiveComponent {\r\n    //TODO: provide details about options for docs - link to a separate page\r\n    /**\r\n     * PrimitiveComponent constructor\r\n     * @param {object} options object settings\r\n     */\r\n    constructor(options) {\r\n        super(options)\r\n        /**\r\n         * the radius of the circle\r\n         * @type {number} radius\r\n         */\r\n        this.radius = options.radius || 0;\r\n    }\r\n\r\n    /**\r\n     * get the bounding box of the circle;\r\n     * @type {{top:number, left: number, bottom:number, right:number}}\r\n     */\r\n    get boundingBox() {\r\n        //TODO: possibly memory-inefficient - need to research:\r\n        //strokes are (were?) centered over the mathematical perimeter -\r\n        //so half the stroke laid within the perimeter, and the\r\n        //other half laid outside. for some reason, this doesn't\r\n        //work for (0 < lineWidth < 2.0).\r\n        //\r\n        //it's just a pixel, but when a thousand objects are on screen,\r\n        //that'll make a difference\r\n        let offset = this.offset;\r\n        let scale = this.compoundScale;\r\n        return {\r\n            top: offset.y -\r\n                ((this.radius * scale.scaleHeight) +\r\n                    (this.style.lineWidth)),\r\n            left: offset.x -\r\n                ((this.radius * scale.scaleWidth) +\r\n                    (this.style.lineWidth)),\r\n            bottom: offset.y +\r\n                (this.radius * scale.scaleHeight) +\r\n                (this.style.lineWidth),\r\n            right: offset.x +\r\n                (this.radius * scale.scaleWidth) +\r\n                (this.style.lineWidth)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * override the render function for drawing circles specifically\r\n     * @override\r\n     */\r\n    render() {\r\n        //the below is to ensure the proper placement when scaling/line widths are accounted for\r\n        let scale = this.compoundScale;\r\n        let lineWidth = this.style.lineWidth;\r\n        drawCircle(\r\n            (this.radius * scale.scaleWidth) + lineWidth,\r\n            (this.radius * scale.scaleHeight) + lineWidth,\r\n            (this.radius * scale.scaleWidth),\r\n            this._prerenderingContext,\r\n            this.style\r\n        );\r\n    }\r\n\r\n    /**\r\n     * determine whether the point is in the object\r\n     * basically just the pythagorean theorem\r\n     * @param {number} x the x coordinate\r\n     * @param {number} y the y coordinate\r\n     * @return {boolean} whether or not the point is in the object\r\n     */\r\n    pointIsInObject(x, y) {\r\n\r\n        let offset = this.offset;\r\n\r\n        //don't bother checking the bounding box because\r\n        //pythagorean formula is closed-form\r\n            let a = x - offset.x;\r\n            let b = y - offset.y;\r\n            let c = this.radius;\r\n\r\n            //thanks pythagoras~!\r\n            return (a * a) + (b * b) <= (c * c);\r\n        //use the below when scaling is reimplemented\r\n        /*\r\n\t\treturn (\r\n\t\t\tCanvasObject.prototype.PointIsInObject.call(this, x, y) &&\r\n\t\t\tMath.pow((x - this.offset.x), 2) / Math.pow((this.radius * this.GlobalScale.scaleWidth), 2) + Math.pow((y - this.offset.y), 2) / Math.pow((this.radius * this.GlobalScale.scaleHeight), 2) <= 1\r\n\t\t);*/\r\n    };\r\n}\r\n"],"file":"Circle.js"}